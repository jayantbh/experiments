{"version":3,"sources":["webpack:///./src/hooks/use-previous.ts","webpack:///./src/components/FlipAnimationTechnique/hooks/use-animation.ts","webpack:///./src/components/FlipAnimationTechnique/index.tsx","webpack:///./src/components/FlipAnimationTechnique/hooks/use-child-aware-animation.ts","webpack:///./src/pages/experiments/flip-animation-technique.tsx"],"names":["usePrevious","value","ref","useRef","useEffect","current","useAnimation","elementRef","animated","_useState","useState","clientRect","setClientRect","prevAnimated","useLayoutEffect","el","first","last","getBoundingClientRect","deltaX","left","deltaY","top","deltaW","width","deltaH","height","animate","transformOrigin","transform","duration","easing","before","after","FlipAnimationTechnique1","setAnimated","toggleAnimation","useCallback","react_default","a","createElement","className","css","container","onClick","style","cls","FlipAnimationTechnique2","_useState2","FlipAnimationTechnique3","_useState3","parentClientRect","setParentClientRect","childClientRect","setChildClientRect","parentEl","childEl","querySelector","parentFirst","parentLast","childFirst","childLast","parentDeltaX","parentDeltaY","parentDeltaW","parentDeltaH","childDeltaW","childDeltaH","fill","useChildAwareAnimation","FlipAnimationTechniqueRouter","_ref","location","react_router","path","component","to","FlipAnimationTechniqueParent","_useState4","isLoaded","setIsLoaded","react_router_dom","navigation","activeClassName","active","Fragment","__webpack_require__","d","__webpack_exports__","frontmatter","title","description","categories"],"mappings":"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","file":"component---src-pages-experiments-flip-animation-technique-tsx-672d9634229cbb9ce6b8.js","sourcesContent":["import { useEffect, useRef } from 'react';\n\nexport const usePrevious = <T>(value: T): T => {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current || ({} as T);\n};\n","import { usePrevious } from 'hooks/use-previous';\nimport { MutableRefObject, useLayoutEffect, useState } from 'react';\n\nexport const useAnimation = (elementRef: MutableRefObject<null | HTMLDivElement>, animated: boolean) => {\n  // Maintain state of the element client rect\n  const [clientRect, setClientRect] = useState(null as null | ClientRect);\n  // Track whether the hook is being called with the same animation state.\n  const { animated: prevAnimated } = usePrevious({ animated });\n\n  // Run a side-effect to work in sync with layout changes because we'll be reading layout stuff\n  useLayoutEffect(() => {\n    // If this was fired with the same animation state as the last call, do nothing\n    if (animated === prevAnimated) return;\n    if (!elementRef || !elementRef.current) return;\n\n    const el = elementRef.current;\n    // Get first client rect from persisted state\n    const first = clientRect;\n    // Get current client rect from DOM\n    const last = el.getBoundingClientRect();\n\n    // Persist current client rect to state, so this is read at the \"first\" client rect next time\n    setClientRect(el.getBoundingClientRect());\n\n    // If either a persisted, or current client rect is missing, do nothing\n    if (!first || !last) return;\n\n    // Calculate the positional difference, and size difference in proportion\n    const deltaX = first.left - last.left;\n    const deltaY = first.top - last.top;\n    const deltaW = first.width / last.width;\n    const deltaH = first.height / last.height;\n\n    // Use the WebAnimations API to make the element appear at the \"first\" phase\n    // by transforming it according to the offsets\n    el.animate(\n      [\n        {\n          transformOrigin: 'top left',\n          transform: `translate(${deltaX}px, ${deltaY}px) scale(${deltaW}, ${deltaH})`,\n        },\n        // And then animate it to the \"last\", or current place by basically disabling the transformed offsets\n        {\n          transformOrigin: 'top left',\n          transform: 'none',\n        },\n      ],\n      {\n        duration: 250,\n        easing: 'ease-in-out',\n      }\n    );\n  }, [elementRef, animated, prevAnimated, clientRect]);\n};\n","import cls from 'classnames';\nimport React, { CSSProperties, useCallback, useEffect, useRef, useState } from 'react';\nimport { HashRouter, NavLink, Redirect, Route, RouteProps, Switch } from 'react-router-dom';\n\nimport { useAnimation } from 'components/FlipAnimationTechnique/hooks/use-animation';\nimport { useChildAwareAnimation } from 'components/FlipAnimationTechnique/hooks/use-child-aware-animation';\nimport css from './styles.module.scss';\n\nconst before: CSSProperties = {\n  height: '100px',\n  width: '100px',\n  left: '200px',\n};\n\nconst after: CSSProperties = {\n  height: '200px',\n  width: '200px',\n  left: '-200px',\n};\n\nconst FlipAnimationTechnique1 = () => {\n  const elementRef = useRef(null as null | HTMLDivElement);\n  const [animated, setAnimated] = useState(false);\n  const toggleAnimation = useCallback(() => setAnimated(!animated), [animated]);\n  useAnimation(elementRef, animated);\n\n  return (\n    <div className={css.container} onClick={toggleAnimation}>\n      <h2>Without nested content</h2>\n      <div className={css['element-wrapper']}>\n        <div ref={elementRef} className={css['element-common-styles']} style={animated ? before : after} />\n      </div>\n      <div className={css['element-wrapper']}>\n        <div className={cls(css['element-common-styles'], css['non-flip'])} style={animated ? before : after} />\n      </div>\n    </div>\n  );\n};\n\nconst FlipAnimationTechnique2 = () => {\n  const elementRef = useRef(null as null | HTMLDivElement);\n  const [animated, setAnimated] = useState(false);\n  const toggleAnimation = useCallback(() => setAnimated(!animated), [animated]);\n  useAnimation(elementRef, animated);\n\n  return (\n    <div className={css.container} onClick={toggleAnimation}>\n      <h2>Without child transitions handling</h2>\n      <div className={css['element-wrapper']}>\n        <div ref={elementRef} className={css['element-common-styles']} style={animated ? before : after}>\n          FLIP\n        </div>\n      </div>\n      <div className={css['element-wrapper']}>\n        <div className={cls(css['element-common-styles'], css['non-flip'])} style={animated ? before : after}>\n          Non-FLIP\n        </div>\n      </div>\n    </div>\n  );\n};\n\nconst FlipAnimationTechnique3 = () => {\n  const elementRef = useRef(null as null | HTMLDivElement);\n  const [animated, setAnimated] = useState(false);\n  const toggleAnimation = useCallback(() => setAnimated(!animated), [animated]);\n  useChildAwareAnimation(elementRef, animated);\n\n  return (\n    <div className={css.container} onClick={toggleAnimation}>\n      <h2>With child transitions handling</h2>\n      <div className={css['element-wrapper']}>\n        <div ref={elementRef} className={css['element-common-styles']} style={animated ? before : after}>\n          <div>FLIP</div>\n        </div>\n      </div>\n      <div className={css['element-wrapper']}>\n        <div className={cls(css['element-common-styles'], css['non-flip'])} style={animated ? before : after}>\n          <div>Non-FLIP</div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nconst FlipAnimationTechniqueRouter = ({ location }: RouteProps) => {\n  return (\n    <Switch location={location}>\n      <Route path={'/route-1'} component={FlipAnimationTechnique1} />\n      <Route path={'/route-2'} component={FlipAnimationTechnique2} />\n      <Route path={'/route-3'} component={FlipAnimationTechnique3} />\n\n      <Redirect to={'/route-1'} />\n    </Switch>\n  );\n};\n\nconst FlipAnimationTechniqueParent = () => {\n  const [isLoaded, setIsLoaded] = useState(false);\n  useEffect(() => {\n    setIsLoaded(true);\n  }, []);\n\n  if (!isLoaded) return <></>;\n  return (\n    <HashRouter>\n      <div className={css.container}>\n        <div className={css.navigation}>\n          <NavLink to={'/route-1'} activeClassName={css.active}>\n            FLIP w/o Children\n          </NavLink>\n          <NavLink to={'/route-2'} activeClassName={css.active}>\n            FLIP w/o Children Handled\n          </NavLink>\n          <NavLink to={'/route-3'} activeClassName={css.active}>\n            FLIP w/ Children Handled\n          </NavLink>\n        </div>\n        <h2>Click to toggle animation state</h2>\n        <Route path={'/'} component={FlipAnimationTechniqueRouter} />\n      </div>\n    </HashRouter>\n  );\n};\n\nexport default FlipAnimationTechniqueParent;\n","import { usePrevious } from 'hooks/use-previous';\nimport { MutableRefObject, useLayoutEffect, useState } from 'react';\n\n// This isn't very reusable for different kinds of layouts, but easily tweakable nonetheless.\n// This is an experiment anyway.\n// Refer to src/components/FlipAnimationTechnique/hooks/use-animation.ts for comments common to both hooks\nexport const useChildAwareAnimation = (elementRef: MutableRefObject<null | HTMLDivElement>, animated: boolean) => {\n  const [parentClientRect, setParentClientRect] = useState(null as null | ClientRect);\n  const [childClientRect, setChildClientRect] = useState(null as null | ClientRect);\n  const { animated: prevAnimated } = usePrevious({ animated });\n\n  useLayoutEffect(() => {\n    if (animated === prevAnimated) return;\n    if (!elementRef || !elementRef.current) return;\n\n    const parentEl = elementRef.current;\n    const childEl = elementRef.current.querySelector('div');\n    if (!childEl) return;\n\n    // Get first and last client rects for both child and parent\n    const parentFirst = parentClientRect;\n    const parentLast = parentEl.getBoundingClientRect();\n\n    const childFirst = childClientRect;\n    const childLast = childEl.getBoundingClientRect();\n\n    setParentClientRect(parentEl.getBoundingClientRect());\n    setChildClientRect(childEl.getBoundingClientRect());\n\n    if (!parentFirst || !parentLast) return;\n    if (!childFirst || !childLast) return;\n\n    const parentDeltaX = parentFirst.left - parentLast.left;\n    const parentDeltaY = parentFirst.top - parentLast.top;\n    const parentDeltaW = parentFirst.width / parentLast.width;\n    const parentDeltaH = parentFirst.height / parentLast.height;\n\n    // Get scale offset for the parent, because we want the child to scale inversely to the parent\n    const childDeltaW = parentLast.width / parentFirst.width;\n    const childDeltaH = parentLast.height / parentFirst.height;\n\n    parentEl.animate(\n      [\n        {\n          transformOrigin: 'top left',\n          transform: `translate(${parentDeltaX}px, ${parentDeltaY}px) scale(${parentDeltaW}, ${parentDeltaH})`,\n        },\n        {\n          transformOrigin: 'top left',\n          transform: 'none',\n        },\n      ],\n      {\n        duration: 250,\n        easing: 'ease-in-out',\n        fill: 'both',\n      }\n    );\n\n    // In this case, the child is centered, so just ensure the child scales correctly.\n    childEl.animate(\n      [\n        {\n          transformOrigin: 'center',\n          transform: `scale(${childDeltaW}, ${childDeltaH})`,\n        },\n        {\n          transformOrigin: 'center',\n          transform: 'none',\n        },\n      ],\n      {\n        duration: 250,\n        easing: 'ease-in-out',\n      }\n    );\n  }, [elementRef, animated, prevAnimated, parentClientRect, childClientRect]);\n};\n","import component from 'components/FlipAnimationTechnique/index';\nexport default component;\n\nexport const frontmatter = {\n  title: 'FLIP Animation Technique',\n  description: 'An example with first-last-invert-play animation technique',\n  categories: ['css', 'animations', 'flip', 'transitions', 'transform'],\n};\n"],"sourceRoot":""}